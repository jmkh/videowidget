'use strict';

var unique = require('./utils').unique;
var isPositiveInt = require('./utils').isPositiveInt;
var stringEndsWith = require('./utils').stringEndsWith;
var SingleValueRegistry = require('./registry').SingleValueRegistry; 
var MultipleValuesRegistry = require('./registry').MultipleValuesRegistry;
var registry = require('./jsFlashBridgeRegistry');
var VPAID_FLASH_HANDLER = 'vpaid_video_flash_handler';
var ERROR = 'AdError';
/**/
function JSFlashBridge(el, flashURL, flashID, width, height, loadHandShake) {
        
        this._el = el;
        this._flashID = flashID;
        this._flashURL = flashURL;
        this._width = width;
        this._height = height;
        this._handlers = new MultipleValuesRegistry();
        this._callbacks = new SingleValueRegistry();
        this._uniqueMethodIdentifier = unique(this._flashID);
        this._ready = false;
        this._handShakeHandler = loadHandShake;
		
        registry.addInstance(this._flashID, this);
	  
        	
};
JSFlashBridge.prototype._handShake=function(err, data) {
            this._ready = true;
            if (this._handShakeHandler) {
                this._handShakeHandler(err, data);
                delete this._handShakeHandler;
            }
        }	
JSFlashBridge.prototype.on=function(eventName, callback) {
        //console.log(["on event 1",this._handlers]);
        this._handlers.add(eventName, callback);
		//console.log(["on event 2",this._handlers]);
}		
JSFlashBridge.prototype.setSize=function(newWidth, newHeight) {
        this._width = isPositiveInt(newWidth, this._width);
        this._height = isPositiveInt(newHeight, this._height);
        this._el.setAttribute('width', this._width);
        this._el.setAttribute('height', this._height);
    }		
JSFlashBridge.prototype.getWidth=function() {
        return this._width;
    }	
JSFlashBridge.prototype.getHeight=function() {
        return this._height;
    }	
JSFlashBridge.prototype.isReady=function() {
    return this._ready;
}
JSFlashBridge.prototype.callFlashMethod =function(methodName, args, callback) {
        var callbackID = '';
        // if no callback, some methods the return is void so they don't need callback
        if (callback) {
            callbackID = this._uniqueMethodIdentifier()+' / '+ methodName;
            this._callbacks.add(callbackID, callback);
        }
	   //console.log(this._el);


        try {
            //methods are created by ExternalInterface.addCallback in as3 code, if for some reason it failed
            //this code will throw an error
            this._el[methodName]([callbackID].concat(args));

        } catch (e) {
		
		console.log(e);
		
            if (callback) {
                $asyncCallback.call(this, callbackID, e);
            } else {

                //if there isn't any callback to return error use error event handler
                this._trigger(ERROR, e);
            }
			
        }
		
};
JSFlashBridge.prototype.offAll = function() {
        return this._handlers.removeAll();
};
JSFlashBridge.prototype.removeCallback=function(callback) {
        return this._callbacks.removeByValue(callback);
    }
JSFlashBridge.prototype.removeAllCallbacks =function() {
        return this._callbacks.removeAll();
};
JSFlashBridge.prototype.destroy = function() {
        this.offAll();
        this.removeAllCallbacks();
        registry.removeInstanceByID(this._flashID);
        if (this._el.parentElement) {
            this._el.parentElement.removeChild(this._el);
        }
    };
JSFlashBridge.prototype._trigger=function(eventName, event) {
var self=this;
        this._handlers.get(eventName).forEach(function(callback){
            //clickThru has to be sync, if not will be block by the popupblocker
            if (eventName === 'AdClickThru') {
                callback(event);
            } else {
                setTimeout(function (){
                    if (self._handlers.get(eventName).length > 0) {
                        callback(event);
                    }
                }, 0);
            }
        });
    };

JSFlashBridge.prototype._callCallback = function(methodName, callbackID, err, result) {

        var callback = this._callbacks.get(callbackID);
       
        //not all methods callback's are mandatory
        //but if there exist an error, fire the error event
        if (!callback) {
            if (err && callbackID === '') {
                this.trigger(ERROR, err);
            }
            return;
        }

        $asyncCallback.call(this, callbackID, err, result);

    };
JSFlashBridge.prototype.removeCallbackByMethodName = function(suffix) {
/*
        this._callbacks.filterKeys(function (key){
           return stringEndsWith(key, suffix);
        }).forEach(function(key) { 
            this._callbacks.remove(key);
        });
*/
};
var $asyncCallback = function(callbackID, err, result) {
//alert(this);
var self=this;
    setTimeout(function (){
        var callback = self._callbacks.get(callbackID);
        if (callback) {
            self._callbacks.remove(callbackID);
            callback(err, result);
        }
    }, 0);
}
Object.defineProperty(JSFlashBridge, 'VPAID_FLASH_HANDLER', {
    writable: false,
    configurable: false,
    value: VPAID_FLASH_HANDLER
});
window[VPAID_FLASH_HANDLER] = function (flashID, typeID, typeName, callbackID, error, data){
   // console.log([typeID,callbackID,typeName,error,data]); 
    var instance = registry.getInstanceByID(flashID);
	
    if (!instance) return;
    if (typeName === 'handShake') {
        instance._handShake(error, data);
    } else {
        if (typeID !== 'event') {
            instance._callCallback(typeName, callbackID, error, data);
        } else {
		
            instance._trigger(typeName, data);
        }
    }
};



module.exports.JSFlashBridge = JSFlashBridge;
